// 1 二维数组中的查找
public class Solution {
    public boolean Find(int target, int [][] array) {
    	int i = array.length - 1;
    	int j = 0;
    	while(i >= 0 && j < array[i].length) {
    		if(array[i][j] > target) 
    			i --;
    		else if(array[i][j] < target) 
    			j ++;
    		else
    			return true;
    	}
    	return false;
    }
}


// 2 替换空格
public class Solution {
    public String replaceSpace(StringBuffer str) {
    	
    	for(int i = 0;i < str.length(); i++) {
    		if(str.charAt(i) == ' ') {
    			str.replace(i, i+1, "%20");
    		}
    	}
    	return str.toString();
    }
}


//3 从尾到头打印链表
/**
*    public class ListNode {
*        int val;
*        ListNode next = null;
*
*        ListNode(int val) {
*            this.val = val;
*        }
*    }
*
*/

import java.util.ArrayList;
public class Solution {
    public static ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> res = new ArrayList<Integer>();
        ListNode p = listNode;
        while(p != null){
            if(p.next == null){
                res.add(0, p.val);
                break;
            }
            res.add(0, p.val);
            p = p.next;
        }
        return res;
    }
}


//重建二叉树
// Arrays.copyOfRange(a, i, j):将数组a的从i(包括i)到j(不包括j)复制，copy和copyofRange的区别？
// arraycopy（Object src, int srcPos, Object dest, int destPos, int length）
// copyOf(oringinal, int newlength)
// copyOfRange(oringinal,int from, int to)
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
import java.util.Arrays;
public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        if(pre.length == 0 || in.length == 0) {
        	return null;
        }
    	TreeNode root = new TreeNode(pre[0]);
    	for(int i = 0; i < in.length; i++) {
    		if(pre[0] == in[i]) {
	        	root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, 1, i+1), Arrays.copyOfRange(in, 0, i));
	        	root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i+1, pre.length), Arrays.copyOfRange(in, i+1, in.length));
    		}
    	}
    	return root;
    }
}

//镜像二叉树，根据先序遍历进行递归

/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public void Mirror(TreeNode root) {
        if(root == null) 
            return;
        if(root.left == null && root.right == null)
            return;
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
        if(root.left != null){
            Mirror(root.left);
        }
        if(root.right != null){
            Mirror(root.right);
        }
    }
}


// 从上往下打印二叉树
// 队列的使用？   remove 删除第一个元素并返回     add 加到末尾  pop()把尾部的删除并返回其值 push到尾部。
import java.util.*;
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {
    	Queue<TreeNode> queue = new LinkedList<TreeNode>();
    	ArrayList<Integer> res = new ArrayList<>();
    	if(root == null) return res;
        queue.add(root);
        while(!queue.isEmpty()) {
        	TreeNode tmp = queue.remove();//只取队列头部的对象
        	res.add(tmp.val);
        	if(tmp.left != null) queue.add(tmp.left);
        	if(tmp.right != null) queue.add(tmp.right);
        }
        return res;
    }
}

// 树的最大深度

public class Solution {
    public int TreeDepth(TreeNode root) {
        if(root == null) return 0;
        int left = TreeDepth(root.left) + 1;
        int right = TreeDepth(root.right) + 1;
        return left > right ? left : right;
    }
}

import java.util.Queue;
import java.util.LinkedList;
public class Solution {
    public int TreeDepth(TreeNode root) {
        if(root == null)
            return 0;
        int deep = 0;
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);
        int start = 0, end = 1;
        while(!queue.isEmpty()){
            TreeNode node = queue.poll();
            start ++;
            if(node.left != null){
                queue.offer(node.left);
            }
            if(node.right != null){
                queue.offer(node.right);
            }
            if(start == end){
                end = queue.size();
                start = 0;
                deep ++;
            }
        }
        return deep;
    }
}